package com.fouryouandme.researchkit.recorder

import android.content.Context
import androidx.lifecycle.MutableLiveData
import com.fouryouandme.core.arch.livedata.Event
import com.fouryouandme.core.arch.livedata.toEvent
import com.fouryouandme.researchkit.recorder.sensor.RecorderData
import com.fouryouandme.researchkit.result.FileResult
import com.fouryouandme.researchkit.step.Step
import java.io.File
import java.util.*

/**
 *
 * A recorder is the runtime companion to an `RecorderConfiguration` object, and is
 * usually generated by one.
 *
 *
 * During active tasks, it is often useful to collect one or more pieces of data
 * from sensors on the device. In research tasks, it's not always
 * necessary to display that data, but it's important to record it in a controlled manner.
 *
 *
 * An active step (`ActiveStep`) has an array of recorder configurations
 * (`RecorderConfiguration`) that identify the types of data it needs to record
 * for the duration of the step. When a step starts, the view instantiates a recorder for each of
 * the step's recorder configurations.
 * The step layout starts the recorder when the active step is started, and stops the
 * recorder when the active step is finished.
 *
 *
 * The results of recording are typically written to a file specified by the
 * value of the `outputDirectory` property.
 *
 *
 * Usually, the view is the recorder's delegate, and it
 * receives callbacks when errors occur or when recording is complete.
 *
 * @property identifier
 * A short string that uniquely identifies the recorder
 * (usually assigned by the recorder configuration).
 *
 * The identifier is reproduced in the results of a recorder created from this configuration.
 * In fact, the only way to link a result
 * (an `FileResult` object) to the recorder that generated it is to look at the value of
 * `identifier`. To accurately identify recorder results, you need to ensure that
 * recorder identifiers are unique within each step.
 *
 * In some cases, it can be useful to link the recorder identifier to a unique identifier in a
 * database; in other cases, it can make sense to make the identifier human
 * readable.
 *
 * @property step
 * The step that produced this recorder, configured during initialization.
 *
 * @property outputDirectory
 * The file URL of the output directory configured during initialization.
 *
 * Typically, you set the `outputDirectory` property for the task object
 * before presenting the task.
 *
 */
abstract class Recorder(
    var identifier: String,
    var step: Step,
    var outputDirectory: File
) {

    /**
     * live data the emit e RecorderData, which represents a data recorded by the recorder
     */
    private val recorderLiveData: MutableLiveData<Event<RecorderData>> = MutableLiveData()

    fun liveData(): MutableLiveData<Event<RecorderData>> = recorderLiveData

    /**
     * A unique filename for this Recorder
     */
    protected val uniqueFilename: String

    /**
     * The configuration that produced this recorder.
     */
    var config: RecorderConfig? = null
        protected set

    /**
     * A Boolean value indicating whether the recorder is currently recording.
     *
     * @return `true` if the recorder is recording; otherwise, `false`.
     */
    var isRecording = false
        protected set

    /**
     * Used to communicate with the listener if the recording completed successfully or failed
     */
    var recorderListener: RecorderListener? = null

    /**
     * Timestamp indicating when the recorder started recording
     */
    var startTime: Long? = null

    /**
     * Timestamp indicating when the recorder ended recording
     */
    var endTime: Long? = null


    init {

        uniqueFilename = generateUniqueFileName()

    }

    /**
     * Starts data recording.
     *
     *
     * If an error occurs when recording starts, it is returned through the delegate.
     *
     * @param context can be app or activity, used for starting sensor
     */
    abstract suspend fun start(context: Context)

    /**
     * Stops data recording, which generally triggers the return of results.
     *
     *
     * If an error occurs when stopping the recorder, it is returned through the delegate.
     * Subclasses should call `finishRecordingWithError:` rather than calling super.
     */
    abstract suspend fun stop(): FileResult?

    /**
     * A cancel will cause this recorder to be immediately stopped,
     * and the file it was writing will be deleted,
     *
     *
     * Also, no callback will be invoked
     */
    abstract suspend fun cancel()

    suspend fun onRecordDataCollected(data: RecorderData): Unit =
        // set the live data value on the main thread
        recorderLiveData.postValue(data.toEvent())

    protected fun onRecorderFailed(error: String): Unit {
        recorderListener?.onFail(this, Throwable(error))
    }

    protected fun onRecorderFailed(throwable: Throwable): Unit {
        recorderListener?.onFail(this, throwable)
    }

    private fun generateUniqueFileName(): String = UUID.randomUUID().toString()

    /**
     * @return a step-specific identifier that can be used for the FileResult
     */
    fun fileResultIdentifier(): String = identifier + "_" + step.identifier

    fun getCurrentRecordingTime(): Long? = startTime?.let { System.currentTimeMillis() - it }

}