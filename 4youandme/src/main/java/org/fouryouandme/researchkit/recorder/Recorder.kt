package org.fouryouandme.researchkit.recorder

import android.content.Context
import android.content.Intent
import androidx.lifecycle.MutableLiveData
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import arrow.core.None
import arrow.core.Option
import arrow.core.some
import arrow.core.toOption
import org.fouryouandme.researchkit.recorder.sensor.RecorderData
import org.fouryouandme.researchkit.result.Result
import org.fouryouandme.researchkit.step.Step
import java.io.File
import java.util.*

/**
 *
 * A recorder is the runtime companion to an `RecorderConfiguration` object, and is
 * usually generated by one.
 *
 *
 * During active tasks, it is often useful to collect one or more pieces of data
 * from sensors on the device. In research tasks, it's not always
 * necessary to display that data, but it's important to record it in a controlled manner.
 *
 *
 * An active step (`ActiveStep`) has an array of recorder configurations
 * (`RecorderConfiguration`) that identify the types of data it needs to record
 * for the duration of the step. When a step starts, the view instantiates a recorder for each of
 * the step's recorder configurations.
 * The step layout starts the recorder when the active step is started, and stops the
 * recorder when the active step is finished.
 *
 *
 * The results of recording are typically written to a file specified by the
 * value of the `outputDirectory` property.
 *
 *
 * Usually, the view is the recorder's delegate, and it
 * receives callbacks when errors occur or when recording is complete.
 *
 * @property identifier
 * A short string that uniquely identifies the recorder
 * (usually assigned by the recorder configuration).
 *
 * The identifier is reproduced in the results of a recorder created from this configuration.
 * In fact, the only way to link a result
 * (an `FileResult` object) to the recorder that generated it is to look at the value of
 * `identifier`. To accurately identify recorder results, you need to ensure that
 * recorder identifiers are unique within each step.
 *
 * In some cases, it can be useful to link the recorder identifier to a unique identifier in a
 * database; in other cases, it can make sense to make the identifier human
 * readable.
 *
 * @property step
 * The step that produced this recorder, configured during initialization.
 *
 * @property outputDirectory
 * The file URL of the output directory configured during initialization.
 *
 * Typically, you set the `outputDirectory` property for the task object
 * before presenting the task.
 *
 */
abstract class Recorder(
    var identifier: String,
    var step: Step,
    var outputDirectory: File
) {

    /**
     * live data the emit e RecorderData, which represents a data recorded by the recorder
     */
    protected val recorderLiveData: MutableLiveData<RecorderData> = MutableLiveData()

    /**
     * A unique filename for this Recorder
     */
    protected val uniqueFilename: String

    /**
     * The configuration that produced this recorder.
     */
    var config: Option<RecorderConfig> = None
        protected set

    /**
     * A Boolean value indicating whether the recorder is currently recording.
     *
     * @return `true` if the recorder is recording; otherwise, `false`.
     */
    var isRecording = false
        protected set

    /**
     * Used to communicate with the listener if the recording completed successfully or failed
     */
    var recorderListener: Option<RecorderListener> = None

    /**
     * Timestamp indicating when the recorder started recording
     */
    var startTime: Option<Long> = None

    /**
     * Timestamp indicating when the recorder ended recording
     */
    var endTime: Option<Long> = None


    init {

        uniqueFilename = generateUniqueFileName()

    }

    /**
     * Starts data recording.
     *
     *
     * If an error occurs when recording starts, it is returned through the delegate.
     *
     * @param context can be app or activity, used for starting sensor
     */
    open fun start(context: Context) {

        startTime = 0L.some()
        endTime = None

    }

    /**
     * Stops data recording, which generally triggers the return of results.
     *
     *
     * If an error occurs when stopping the recorder, it is returned through the delegate.
     * Subclasses should call `finishRecordingWithError:` rather than calling super.
     */
    open fun stop() {

        endTime = System.currentTimeMillis().some()

    }

    /**
     * A cancel will cause this recorder to be immediately stopped,
     * and the file it was writing will be deleted,
     *
     *
     * Also, no callback will be invoked
     */
    abstract fun cancel()

    fun onRecordDataCollected(data: RecorderData): Unit {

        recorderLiveData.value = data

    }

    protected fun onRecorderCompleted(result: Result): Unit {
        recorderListener.map { it.onComplete(this, result) }
    }

    protected fun onRecorderFailed(error: String): Unit {
        recorderListener.map { it.onFail(this, Throwable(error)) }
    }

    protected fun onRecorderFailed(throwable: Throwable): Unit {
        recorderListener.map { it.onFail(this, throwable) }
    }

    protected fun sendBroadcast(intent: Intent): Unit {
        recorderListener
            .flatMap { it.broadcastContext.toOption() }
            .map { LocalBroadcastManager.getInstance(it).sendBroadcast(intent) }
    }

    private fun generateUniqueFileName(): String = UUID.randomUUID().toString()

    /**
     * @return a step-specific identifier that can be used for the FileResult
     */
    fun fileResultIdentifier(): String = identifier + "_" + step.identifier

    fun getCurrentRecordingTime(): Option<Long> = startTime.map { System.currentTimeMillis() - it }

}